{"version":3,"file":"deeplinks.js","sources":["../src/versions/1.ts","../src/util/base64.ts","../src/util/cyrb53.ts","../src/deeplinks.ts"],"sourcesContent":["import { cyrb53 } from '../util/cyrb53';\nimport { fromNumber } from '../util/base64';\n\n// See docs/spec/v1.md for what this code implements.\n// It must also be compatible with docs/spec/v0.md.\n\n// See https://dom.spec.whatwg.org/#interface-node\n// The minifier isn't smart enough to know this, so do it ourselves and save\n// the, uh 26 bytes...\nconst TEXT_NODE = 3;\n// Same as above, see https://dom.spec.whatwg.org/#interface-nodefilter\nconst NODEFILTER_SHOW_TEXT = 0x04;\n\nfunction hashNode(n: Text): string {\n  return fromNumber(cyrb53(n.wholeText));\n}\n\n// Take a range, and return a new range containing the same text, but ensuring\n// that the start and end are both non-whitespace-only text nodes.\nfunction normalizeRange(range: Range) {\n  // We start off by picking start and end nodes. If the start node is a text\n  // node, we can just use it as is. If it's a element node, though, we need to\n  // use the offset to figure out which child node is the one that's actually\n  // selected.\n  //\n  // There's a additional hiccup that the offsets used by Range represent the\n  // spaces in between child nodes, while the TreeWalker API operates on the\n  // nodes directly. Because of this, we need to keep track of whether the\n  // selected text starts/ends before or after the start/end node. The\n  // startOffset/endOffset variables do double duty in this regard — if the\n  // startNode/endNode is a text node, the startOffset/endOffset is a text\n  // offset, but if the startNode/endNode is a element node, they represent\n  // whether the selection starts/ends before the node (0) or after the node\n  // (1).\n\n  const makeNodeAndOffset = (initNode: Node, initOffset: number): [Node, number] => {\n    let node, offset;\n    if (initNode.nodeType == TEXT_NODE || initNode.childNodes.length == 0) {\n      node = initNode;\n      offset = initOffset;\n    } else {\n      node = initNode.childNodes[Math.min(initOffset, initNode.childNodes.length - 1)];\n      if (node.nodeType == TEXT_NODE) {\n        offset = (initOffset == initNode.childNodes.length) ? (node as Text).wholeText.length : 0;\n      } else {\n        offset = (initOffset == initNode.childNodes.length) ? 1 : 0;\n      }\n    }\n    return [node, offset];\n  };\n\n  const [startNode, startOffset] = makeNodeAndOffset(range.startContainer, range.startOffset);\n  const [endNode, endOffset] = makeNodeAndOffset(range.endContainer, range.endOffset);\n\n  const newRange = new Range();\n  const treeWalker = document.createTreeWalker(range.commonAncestorContainer);\n  // stages:\n  // 0 = Looking for startNode.\n  // 1 = startNode found, but it wasn't a non-empty text node — looking for a\n  //     non-empty text node.\n  // 2 = Looking for endNode.\n  let stage = 0;\n  let node: Node | null = treeWalker.currentNode;\n  let prevEndNode = endNode;\n  while (node) {\n    if (stage == 0 && node == startNode) {\n      if (node.nodeType != TEXT_NODE && startOffset != 0) {\n        node = treeWalker.nextNode();\n        if (!node) {\n          return null;\n        }\n      }\n      stage = 1;\n    }\n    if (node.nodeType == TEXT_NODE && (node as Text).wholeText.trim() != '') {\n      if (stage == 1) {\n        newRange.setStart(node, (node == startNode) ? startOffset : 0);\n        stage = 2;\n      }\n      if (stage == 2) {\n        prevEndNode = newRange.endContainer;\n        newRange.setEnd(node, (node as Text).wholeText.length);\n      }\n    }\n    if (stage == 2 && node == endNode) {\n      if (node.nodeType == TEXT_NODE && (node as Text).wholeText.trim() != '') {\n        newRange.setEnd(node, endOffset);\n        return newRange;\n      }\n      if (node == newRange.endContainer && endOffset == 0) {\n        newRange.setEnd(prevEndNode, (prevEndNode as Text).wholeText.length);\n      }\n      return newRange;\n    }\n    node = treeWalker.nextNode();\n  }\n\n  return null;\n}\n\nexport function selectionToFragment(selection: Selection): string {\n  type HashNodeOffset = [string, Text, number];\n  type DupeData = [boolean[], number, number];\n  const ranges: [HashNodeOffset, HashNodeOffset, DupeData][] = [];\n  for (let i = 0; i < selection.rangeCount; i++) {\n    const range = normalizeRange(selection.getRangeAt(i));\n    if (range && !range.collapsed) {\n      const [startNode, endNode] = [range.startContainer, range.endContainer];\n      if (startNode.nodeType == TEXT_NODE && endNode.nodeType == TEXT_NODE) {\n        ranges.push([\n          [hashNode(startNode as Text), startNode as Text, range.startOffset],\n          [hashNode(endNode as Text), endNode as Text, range.endOffset],\n          [[], 0, 0],\n        ]);\n      }\n    }\n  }\n\n  if (ranges.length == 0) {\n    return '';\n  }\n\n  const walk = document.createTreeWalker(document.body, NODEFILTER_SHOW_TEXT);\n  let node;\n  while (node = walk.nextNode() as Text) { // eslint-disable-line no-cond-assign\n    const hash = hashNode(node);\n    for (const [[startHash, startNode], [endHash, endNode], dupes] of ranges) {\n      if (startNode == node) {\n        dupes[1] = dupes[0].length;\n      }\n      if (endNode == node) {\n        dupes[2] = dupes[0].length;\n      }\n      if (startHash == hash) {\n        dupes[0].push(true);\n      } else if (endHash == hash) {\n        dupes[0].push(false);\n      }\n    }\n  }\n\n  const fragmentParts = ranges.map(([[startHash, , startOffset], [endHash, , endOffset], [dupes, startDupeOffset, endDupeOffset]]) => {\n    let fragmentPart;\n    if (startHash == endHash) {\n      fragmentPart= `${startHash}:${startOffset}:${endOffset}`;\n    } else {\n      fragmentPart= `${startHash}:${startOffset}.${endHash}:${endOffset}`;\n    }\n    if (new Set(dupes).size != dupes.length) {\n      const dupesString = dupes.map(x => x ? 's' : 'e').join('');\n      fragmentPart += `~${dupesString}~${startDupeOffset}~${endDupeOffset}`;\n    }\n    return fragmentPart;\n  });\n\n  return `#1${fragmentParts.join()}`;\n}\n\nfunction getRangeFromFragmentPart(fragmentPart: string): Range {\n  const [hashOffsetFragmentPart, dupeString, dupeStartOffset, dupeEndOffset] = fragmentPart.split('~');\n  const split = hashOffsetFragmentPart.split('.').map((x) => x.split(':'));\n  let startHash, startOffset, endHash, endOffset;\n  if (split.length == 1) {\n    [[startHash, startOffset, endOffset]] = split;\n    endHash = startHash;\n  } else {\n    [[startHash, startOffset], [endHash, endOffset]] = split;\n  }\n  [startOffset, endOffset] = [startOffset, endOffset].map(parseFloat);\n\n  // the boolean represents whether it's a start node (true) or end node (false)\n  const nodes: [Text, boolean][] = [];\n\n  const walk = document.createTreeWalker(document.body, NODEFILTER_SHOW_TEXT, null);\n  let node, numEndNodes = 0;\n  while (node = walk.nextNode() as Text) { // eslint-disable-line no-cond-assign\n    const hash = hashNode(node);\n    if (hash == startHash) {\n      nodes.push([node, true]);\n    } else if (hash == endHash) {\n      nodes.push([node, false]);\n      numEndNodes++;\n    }\n  }\n\n  let startNode, endNode;\n\n  if (dupeString && nodes.map(n => n[1] ? 's' : 'e').join('') == dupeString) {\n    startNode = nodes[parseInt(dupeStartOffset)];\n    endNode = nodes[parseInt(dupeEndOffset)];\n  }\n\n  if (!startNode || !endNode) {\n    if (startHash == endHash) {\n      startNode = nodes[0];\n      endNode = startNode;\n    } else {\n      // If there's more than one end node, start with the start node.  This\n      // ensures that in cases where both nodes are ambiguous, the first pair is\n      // selected.\n      const anchorNodeType = numEndNodes > 1;\n      const anchorNodeIndex = nodes.findIndex(e => e[1] == anchorNodeType);\n      startNode = nodes[anchorNodeType ? anchorNodeIndex : anchorNodeIndex - 1];\n      endNode = nodes[anchorNodeType ? anchorNodeIndex + 1: anchorNodeIndex];\n    }\n  }\n\n  const range = new Range();\n  if (startNode && endNode) {\n    range.setStart(startNode[0], startOffset);\n    range.setEnd(endNode[0], endOffset);\n  }\n  return range;\n}\n\nexport function fragmentToRangeList(fragment: string): Range[] {\n  return fragment.replace(/^1\\.?/gm, '').split(',').map(getRangeFromFragmentPart);\n}\n","// https://stackoverflow.com/questions/6213227/fastest-way-to-convert-a-number-to-radix-64-in-javascript/6573119#6573119\n// modified for typescript/general modernization/aesthetics/etc\n// the alphabet has also been changed to use more reasonable characters for a url.\n\nconst _rixits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_';\n\n// This cannot handle negative numbers and only works on the integer part,\n// discarding the fractional part. Doing better means deciding on whether\n// you're just representing the subset of javascript numbers of\n// twos-complement 32-bit integers or going with base-64 representations for\n// the bit pattern of the underlying IEEE floating-point number, or\n// representing the mantissae and exponents separately, or some other\n// possibility. For now, bail\nexport function fromNumber(number: number): string {\n  if (isNaN(number) || number === Infinity || number < 0) {\n    throw 'invalid input';\n  }\n\n  let result = '', rixit; // like 'digit', only in some non-decimal radix\n  number = Math.floor(number);\n  for (;;) {\n    rixit = number % 64;\n    result = _rixits.charAt(rixit) + result;\n    number = Math.floor(number / 64);\n\n    if (number == 0) { break; }\n  }\n  return result;\n}\n\nexport function toNumber(string: string): number {\n  let result = 0;\n  const rixits = string.split('');\n  for (let e = 0; e < rixits.length; e++) {\n    result = (result * 64) + _rixits.indexOf(rixits[e]);\n  }\n  return result;\n}\n","// this function has been taken from the stack overflow post linked below, with\n// the modification that the seed has been removed, since it was unused\n// anyways.\n//\n// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n\nexport const cyrb53 = function(str: string): number {\n  let h1 = 0xdeadbeef, h2 = 0x41c6ce57;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);\n  h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1>>>0);\n};\n","import * as v1 from './versions/1';\n\nfunction selectRanges(ranges: Range[]) {\n  const selection = document.getSelection() as Selection;\n  selection.removeAllRanges();\n  for (const range of ranges) {\n    selection.addRange(range);\n  }\n  ranges[0].startContainer.parentElement?.scrollIntoView();\n  if (selection.rangeCount != ranges.length) {\n    void import('./e').then(error => error.m(ranges));\n  }\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const fragment = location.hash.slice(1);\n\n  if (fragment && !document.getElementById(fragment)) {\n    if (fragment[0] == '1') {\n      selectRanges(v1.fragmentToRangeList(fragment));\n    }\n  }\n\n  // This is in a setTimeout to ensure that the code above does all of its\n  // selection-changing before this executes. This ensures that we don't\n  // clobber changes that we just made (for instance, in the case of a user\n  // on Chrome attempting to open a multiselect url).\n  //\n  // This also allows us to make more careful decisions about rewriting urls\n  // in general — we can explicitly decide when and how to do version bumps,\n  // for instance.\n  setTimeout(() => {\n    document.addEventListener('selectionchange', () => {\n      const fragment = v1.selectionToFragment(document.getSelection() as Selection);\n      // replaceState is used instead of setting location.hash to avoid scrolling.\n      history.replaceState(null, '', location.pathname + fragment);\n    });\n  }, 0);\n});\n"],"names":["hashNode","n","number","isNaN","Infinity","rixit","result","Math","floor","charAt","fromNumber","str","h1","h2","ch","i","length","charCodeAt","imul","cyrb53","wholeText","normalizeRange","range","makeNodeAndOffset","initNode","initOffset","node","offset","nodeType","childNodes","min","startNode","startOffset","startContainer","endNode","endOffset","endContainer","newRange","Range","treeWalker","document","createTreeWalker","commonAncestorContainer","stage","currentNode","prevEndNode","nextNode","trim","setStart","setEnd","getRangeFromFragmentPart","fragmentPart","hashOffsetFragmentPart","dupeString","dupeStartOffset","dupeEndOffset","split","map","x","startHash","endHash","parseFloat","nodes","walk","body","numEndNodes","hash","push","join","parseInt","anchorNodeType","anchorNodeIndex","findIndex","e","addEventListener","fragment","location","slice","getElementById","ranges","selection","getSelection","removeAllRanges","addRange","parentElement","scrollIntoView","rangeCount","import","then","error","m","selectRanges","replace","v1.fragmentToRangeList","setTimeout","getRangeAt","collapsed","dupes","startDupeOffset","endDupeOffset","Set","size","v1.selectionToFragment","history","replaceState","pathname"],"mappings":"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"}