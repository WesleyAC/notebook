<!DOCTYPE html>
<html lang="en-us"><head prefix="og: http://ogp.me/ns#; dc: http://purl.org/dc/terms/#">
  
  
  <!-- Canonical link to help search engines -->
  <link rel="canonical" href="https://blog.pimaker.at/texts/rvc1/">

  <!-- Basic meta elements -->
  <meta charset="utf-8">

  <!-- Enable responsiveness on mobile devices -->
  <meta name="viewport" content="width=device-width,initial-scale=1.0,shrink-to-fit=no">

  <title>
    
      Linux in a Pixel Shader - A RISC-V Emulator for VRChat
    
  </title>

  <!-- Google Search Console -->
  <meta name="google-site-verification" content="6Ps9UMFwp-rawklRpCu_JxfOlhWk0XRYP2sY4rqGA4A">

  <!-- Dublin Core metadata for Zotero -->
  <meta property="dc:title" content="Linux in a Pixel Shader - A RISC-V Emulator for VRChat">
  <meta property="dc:creator" content="_pi_">
  <meta property="dc:identifier" content="https://blog.pimaker.at/texts/rvc1/">
  
  
  
  <meta property="dc:source" content="_pi_'s blog">

  <!-- Open Graph metadata -->
  <meta property="og:title" content="Linux in a Pixel Shader - A RISC-V Emulator for VRChat">
  <meta property="og:url" content="https://blog.pimaker.at/texts/rvc1/">
  <meta property="og:image" content="https://blog.pimaker.at/assets/open-graph-logo.png">
  <meta property="og:image:width" content="200">
  <meta property="og:image:height" content="200">


  <meta property="og:description" content="Linux in a Pixel Shader - A RISC-V Emulator for VRChat">
  <meta property="og:type" content="article">


  <!-- Tracking - no, nothing bad, just a self-hosted view counter out of personal interest, I swear -->
  
  <script async="" src="https://tracking.pimaker.at/blog-Linux in a Pixel Shader - A RISC-V Emulator for VRChat/count.js"></script>
  

  <!-- CSS link -->
  <link rel="stylesheet" href="/assets/css/style.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="180x180" href="/assets/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/assets/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.pimaker.at/atom.xml">
</head>


  <body class="theme-base-blue">

    <!-- This if statement decides which sidebar to use -->
    
    <!--
  Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for
  behavior.
-->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<aside class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>PiMaker / _pi_ / Stefan's technology blog. Sometimes about Linux, VRChat or Shaders. Somtimes about all of the above.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/"><b>Home</b></a>

    

    
    
      
        
          <a class="sidebar-nav-item active" href="/texts/rvc1/">Linux in a Pixel Shader - A RISC-V Emulator for VRChat</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/texts/welcome/">initial commit</a>
        
      
    

    <!-- The code below is used for manually entered links  -->
    <!-- <span style='cursor:pointer;' onclick="javascript:var hypothesis = document.createElement('script'); -->
    <!--   hypothesis.setAttribute('src','https://hypothes.is/embed.js'); -->
    <!--   document.head.appendChild(hypothesis);"><a class="sidebar-nav-item">Annotate me</a></span> -->

  <!--
    <a class="sidebar-nav-item" href="https://via.hypothes.is/https://blog.pimaker.at/texts/rvc1//" data-proofer-ignore>Annotate me</a>
    <script src="https://hypothes.is/embed.js" async></script>
  -->

    <!-- <a class="sidebar-nav-item" href="https://github.com/minicomp/ed" target="_blank">GitHub project</a> -->
  </nav>

  <div class="sidebar-item">
    <p>
      Built with <a href="https://minicomp.github.io/ed/">Ed.</a>
    </p>
  </div>
</aside>

    

    <!--
      Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS
      collisions with our real content.
    -->
    <div class="wrap">
      <header class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">_pi_'s blog</a>
            <br><small>cursed technology stuff</small>
          </h3>
        </div>
      </header>

      <main class="container content" id="main">
        <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<article class="page">
  <h1 class="page-title">Linux in a Pixel Shader - A RISC-V Emulator for VRChat</h1>
  <i>25 August 2021</i>, by _pi_<br>
  <small><span id="viewCount">59800</span>&nbsp;views</small>
  <p><small>for comments see <a href="https://news.ycombinator.com/item?id=28312632">Hacker News</a>, <a href="https://www.reddit.com/r/programming/comments/pbw5ze/linux_in_a_pixel_shader_a_riscv_emulator_for/">r/programming</a> or <a href="https://www.reddit.com/r/VRchat/comments/pbwae1/i_made_linux_run_in_vrchat_info_in_comments/">r/vrchat</a></small></p>

<h1 id="intro">Intro</h1>

<p>Sometimes you get hit with ideas for side-projects that sound absolutely plausible in your head. The idea grips you, your mind’s eye can practically visualize it already. And then reality strikes, and you realize how utterly insane this would be, and just <em>how much</em> work would need to go into it.</p>

<p>Usually these ideas appear, I enjoy dissecting them for a few days, and then I move on. But sometimes. Sometimes I decide to double down and get Linux running on my graphics card.</p>

<p>This is the story of how I made the <code class="language-plaintext highlighter-rouge">rvc</code> RISC-V emulator within VRChat, and a deep-dive into the unusual techniques required to do it.</p>

<p>Here are some specs up front, if you’re satisfied with piecing the story together yourself:</p>

<ul>
  <li>the code is on <strong><a href="https://github.com/pimaker/rvc">GitHub</a></strong></li>
  <li>emulated RISC-V <code class="language-plaintext highlighter-rouge">rv32ima/su+Zifencei+Zicsr</code> instruction set</li>
  <li>64 MiB of RAM minus CPU state is stored in a 2048x2048 pixel Integer-Format texture (128 bpp)</li>
  <li>Unity Custom Render Texture with buffer-swapping allows encoding/decoding state between frames</li>
  <li>a pixel shader is used for emulation since compute shaders and UAV are not supported in VRChat</li>
</ul>

<p><img src="../../assets/dab.jpg" alt="me standing in front of a booted linux in VRChat">
<small>(image credit: <a href="https://github.com/pema99">@pema99</a>, thanks!)</small></p>

<p><em>Be warned that this post might be a bit rambly at times, as I try to recall the many pitfalls of writing this shader. Let’s hope it will at least turn out entertaining.</em></p>

<hr>
<h1 id="about-the-project">About the project</h1>

<p>Around March 2021 I decided on writing an emulator capable of running a full Linux Kernel in VRChat. Due to the inherent limitations of that platform, the tool of choice had to be a shader. And after a few months of work, I’m now proud to present the worlds first (as far as I know) RISC-V CPU/SoC emulator in an HLSL pixel shader, capable of running up to 250 kHz (on a 2080 Ti) and booting Linux 5.13.5 with MMU support.</p>

<p>You can experience the result of all this for yourself by visiting <a href="https://vrchat.com/home/world/wrld_8126d9ef-eba5-4d49-9867-9e3c4f0b290d">this VRChat world</a>. You will require a <a href="https://hello.vrchat.com/">VRChat</a> account and the corresponding client, both of which are free and give you access to a massive social platform full of user-created content such as this (no VR headset required!).</p>

<p><img src="../../assets/rvc_overview.jpg" alt="rvc test world with booted linux">
<small>(a screenshot of the VRChat world and interface to use the emulator)</small></p>

<p>Here’s me in my Avatar again, standing in front of a kernel panic:</p>

<p><img src="https://raw.githubusercontent.com/PiMaker/rvc/master/panic.jpg" alt="me standing in front of a kernel panic">
<small>(image credit: <a href="https://github.com/pema99">@pema99</a> as well, I believe)</small></p>

<p>This picture was taken after I showed off my work at the community meetup, a self-organized weekly get-together of VRChat creators from all over. Here’s a recording of the live-stream where I presented it, it’s fun to see everyone’s reactions when I unveiled my big “secret project”:</p>

<div style="width:100%;padding-bottom:56.25%;margin-bottom:16pt;position:relative"><iframe style="width:100%;height:100%;position:absolute" src="https://www.youtube-nocookie.com/embed/G2u7NOpzcBQ?start=5052" title="YouTube video player" frameborder="0" allow="autoplay; clipboard-write; encrypted-media; picture-in-picture" allowfullscreen=""></iframe></div>

<p>Thanks to the team organizing the event for providing me with the opportunity!</p>

<p>The project has been featured on <a href="https://blog.adafruit.com/2021/08/16/linux-on-a-simulated-risc-v-chip-in-a-graphics-card-fragment-shader-riscv-linux-emulation/">Adafruit</a>, and my friend @fuopy over on twitter has posted video evidence as well:</p>

<blockquote class="twitter-tweet" data-dnt="true" data-theme="light"><p lang="en" dir="ltr">Linux running in a shader! By _pi_! Check it out!!<br>(5x speed of Linux running in a fragment shader emulating RISC-V) World link:<a href="https://t.co/jYnR8AZrQM">https://t.co/jYnR8AZrQM</a><br> <a href="https://twitter.com/hashtag/vrchat?src=hash&amp;ref_src=twsrc%5Etfw">#vrchat</a> <a href="https://twitter.com/hashtag/shaders?src=hash&amp;ref_src=twsrc%5Etfw">#shaders</a> <a href="https://t.co/gqW6qSXLb2">pic.twitter.com/gqW6qSXLb2</a></p>— fuopy (@fuopy) <a href="https://twitter.com/fuopy/status/1427051048032620544?ref_src=twsrc%5Etfw">August 15, 2021</a></blockquote>

<p>The response I’ve received in the days afterwards was tremendously positive. A seriously big thank you to everyone who asked for details, suggested improvements, shared the world, or simply shook their head in disbelieve towards me.</p>

<hr>
<h1 id="a-tribute-to-vrchats-creative-community">A Tribute to VRChat’s Creative Community</h1>

<p>I am a big VR enthusiast - I was among the first to even try the original Vive here in Austria, and never looked back since. But it was only when a friend invited me into VRChat around August 2020, that I was introduced to the amazing creative-community surrounding that “game”/social platform.</p>

<p>I can’t speak for the visual side that much, though I dearly admire people who can summon 3D models and environments from scratch. Luckily, VRChat had recently released <a href="https://docs.vrchat.com/docs/what-is-udon">Udon</a>, which allows world crafters to run custom code within their creations. This opened the door to the likes of myself, people who enjoy coding for fun and just want to push the envelope of what can be made.</p>

<p>Udon works super well for anything that doesn’t require high performance. The built-in visual programming combined with <a href="https://github.com/MerlinVR/UdonSharp">@MerlinVR’s UdonSharp</a> (a C#-to-Udon compiler) are vital for making interactive worlds these days. People are using it to create incredible experiences, anything from multiplayer PvP games to petting zoos for ducks and dogs (and sometimes other players) - it is what got me interested in making content for VRChat in the first place.</p>

<p><img src="../../assets/udon-ducks.webp" alt="Udon Bird Sanctuary">
<small>(image credit: <a href="https://www.reddit.com/user/1029chris">u/1029chris</a>)</small></p>

<p>What really sparked my imagination however, was the discovery that you can embed your own, custom shaders within such a world. You can even put them on your Avatars! With shaders, the sky is the limit - and if you take even just a cursory look at what the community has done in VRChat, you realize that even that is only a limit meant to be broken.</p>

<p>I like to compare it to demoscening. Instead of cramming stuff into limited storage space, you work around the limitations the platform imposes on you - there’s so many things you can’t do, that part of the challenge is to figure out what you <em>can</em> do. Or as resident shader magician <a href="https://github.com/cnlohr/">@cnlohr</a> put it:</p>

<blockquote>
  <p>I love how VRC programmers have a way of looking at [a] wall of restrictions, then find a way of switching their existence to a zero dimensional object for a moment, then they appear on the other side of that wall.</p>
</blockquote>

<p><img src="../../assets/treehouse_in_the_shade.jpg" alt="Treehouse in the Shade"></p>

<p>Pictured above is “Treehouse in the Shade”, one of the most famous shader worlds, with an unfortunately tragic <a href="https://medium.com/vrchat/remembering-1001-973ac391c4df">backstory</a>. It is indeed a beautiful world I have spent a good amount of time in myself.</p>

<p>One of its co-creators, SCRN, has also written some less visual, but more technical VRChat projects, like this <a href="https://github.com/SCRN-VRC/SimpNet-Deep-Learning-in-a-Shader">deep learning shader</a>.</p>

<p>Since discovering VRChat and the creator community, I have made several of my own custom Avatars and Worlds. Some are finished, some left as demonstrations of what <em>could</em> be.</p>

<p>And then, back in February or March of 2021, this little spark of an idea popped up in my head - if I could run anything I want in a VRChat world, then why not go for the end-goal straight away: Let’s run a Linux kernel!</p>

<hr>
<h1 id="compute-shaders-in-vrchat">Compute Shaders in VRChat</h1>

<p>Udon, as mentioned above, comes fairly close to regular coding. It’s semantically equivalent to writing Unity behaviour scripts, and can utilize most of what C# has to offer using UdonSharp.</p>

<p>However, to quote from UdonSharp’s documentation:</p>

<blockquote>
  <p>Udon can take on the order of 200x to 1000x longer to run a piece of code than the equivalent in normal C# depending on what you’re doing. […] Just 40 iterations of something can often be enough to visibly impact frame rate on a decent computer.</p>
</blockquote>

<p>With this performance constraint in mind, it becomes clear that CPU emulation is simply infeasible[<a href="#ref0" id="ref0b">0</a>].</p>

<p>As far as I know there’s only two ways you can write custom code and have it execute in VRChat: Udon and shaders. This is important for security concerns of course, as Udon is a VM and shaders only run on the GPU. Since the former is out of the question, that leaves us with shaders.</p>

<p>But hold up, I hear you say, shaders are the little programs telling your GPU how to make things look good, right? How could you possibly emulate a CPU on that? And isn’t that kind of stupid?</p>

<p>Correct; By using compute shaders; And yes.</p>

<p>A “compute shader” doesn’t output an image, but simply data. It allows, in theory, to run highly parallel code on the GPU to compute any value. This is the principle behind CUDA, but is also used in games.</p>

<p>That sounds too easy though - and indeed it is, VRChat doesn’t allow you to use them in your creations. However, we can use some trickery here: By pointing Unity’s <code class="language-plaintext highlighter-rouge">Camera</code> object at a quad rendered with our shader[<a href="#ref1" id="ref1b">1</a>], and then assigning the output RenderTexture (the target buffer) to an input of our shader, we have essentially created a writable persistent state storage - the basic building block for a compute operation. Any pixel we write during the fragment (aka pixel) shader stage, we will be able to read back next frame.</p>

<p><img src="https://raw.githubusercontent.com/pema99/shader-knowledge/main/images/CamLoop1.png" alt="Unity Camera Loop">
<small>(image credit: @pema99 and their fantastic <a href="https://github.com/pema99/shader-knowledge">treasure trove</a> of forbidden VRChat shader knowledge)</small></p>

<p>Of course there’s a bunch of texture alignment and Unity trickery necessary to make it work, but people have been using this technique for a long time, and it turns out to be surprisingly realiable. You can even use it on an Avatar, I managed to implement a basic calculator with it once.</p>

<p>The issue with that is of course that a fragment shader runs in parallel for every pixel on the texture, and every instance can only output to one of them in the end. We’ll see how to (mostly) work around that later.</p>

<p><small id="ref0">[0] I feel the need to point out that someone <em>did</em>, in fact, <a href="https://vrchat.com/home/world/wrld_d9092c8e-3484-4ee2-8598-fba583a918f9">emulate a full CHIP-8 in Udon alone</a>, and someone else <a href="https://vrchat.com/home/world/wrld_6528a90d-4806-4df9-b922-0af2fe7b0a9d">tried their hand at a 6502</a> - both projects run very slowly however, certainly too slow to get an OS booted… <a href="#ref0b">⏎</a></small></p>

<p><small id="ref1">[1] or in this case we’re using a Custom Render Texture, which is basically the same thing, but more cursed<em>^W</em>compact <a href="#ref1b">⏎</a></small></p>

<hr>
<h1 id="excursion-risc-v">Excursion: RISC-V</h1>

<p>If you want to create a system capable of running Linux, you need to decide on which supported CPU architecture you want to emulate. Take a look into the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch">kernel source</a>, and you will see that there are quite a bunch available.</p>

<p>For our purposes, it is important that the ISA is as simple as possible, not just because I’m lazy, but also because shaders have both theoretical and practical limitations when it comes to program size and complexity.</p>

<p>I decided on RISC-V, mostly because I liked their mission in general - an open source CPU architecture is something to be fond of, and I had been following efforts to port Linux software to it with great interest. These days you can run a full <a href="https://wiki.debian.org/RISC-V">Debian</a> on some hardware RISC-V boards.</p>

<p>It of course helps that all the specifications for RISC-V are <a href="https://riscv.org/technical/specifications/">published freely</a> on the internet, and there are good reference implementations available (shout out to <a href="https://github.com/takahirox/riscv-rust">takahirox/riscv-rust</a>).</p>

<p><img src="../../assets/riscv.jpg" alt="RISC-V logo"></p>

<hr>
<h1 id="writing-an-emulator-in-hlsl-c">Writing an emulator in <del>HLSL</del> C</h1>

<p>But back to making our emulator. First problem: Debugging a shader is hard. You can’t just attach GDB and single step, or even add <code class="language-plaintext highlighter-rouge">printf</code> statements throughout your code. There are shader debugging tools out there, but they mostly focus on the <em>visual</em> side of things, and aren’t that helpful when you’re trying to run what is basically linear code.</p>

<p>Luckily for us, <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl">HLSL</a>, the language we use to write shaders in Unity, is remarkably similar to regular C. And so the first iteration of the emulator was written in C.</p>

<p>Of course, some prep-work to translating already went into it. If you were to show the code of the C version to any seasoned C programmer, they would shudder and call an exorcist[<a href="#ref2" id="ref2b">2</a>].</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define UART_GET1(x) ((cpu-&gt;uart.rbr_thr_ier_iir &gt;&gt; SHIFT_##x) &amp; 0xff)
#define UART_GET2(x) ((cpu-&gt;uart.lcr_mcr_lsr_scr &gt;&gt; SHIFT_##x) &amp; 0xff)
</span>
<span class="cp">#define UART_SET1(x, val) cpu-&gt;uart.rbr_thr_ier_iir = (cpu-&gt;uart.rbr_thr_ier_iir &amp; ~(0xff &lt;&lt; SHIFT_##x)) | (val &lt;&lt; SHIFT_##x)
#define UART_SET2(x, val) cpu-&gt;uart.lcr_mcr_lsr_scr = (cpu-&gt;uart.lcr_mcr_lsr_scr &amp; ~(0xff &lt;&lt; SHIFT_##x)) | (val &lt;&lt; SHIFT_##x)
</span></code></pre></div></div>
<p><small>(excerpt from the <a href="https://github.com/PiMaker/rvc/blob/cb6d051/src/uart.h">UART driver</a>; packing logic for UART state since HLSL only has 32-bit variables)</small></p>

<p>After a few evenings spent coding, I got to a point where the <a href="https://github.com/riscv/riscv-tests">riscv-tests</a> suite passed for the integer base set (rv32i). The reason we’re going for 32-bit is because the version of DirectX that VRChat is based on only supports 32-bit integers on GPUs. In fact, at least historically speaking, even most GPU <em>hardware</em> has rather poor support for 64-bit integers.</p>

<p>I had figured out already that for Linux support I needed the ‘m’ (integer multiplication) and ‘a’ (atomics) extensions, as well as CSR and memory fencing support. Atomics are implemented as simple direct operations, as the system features only one hart (‘core’) anyway. CSRs are fully implemented, fencing is simply a no-op in C (in HLSL this becomes more important).</p>

<p>Multiplication is fully working in C, but not in HLSL - it requires the <code class="language-plaintext highlighter-rouge">mulh</code> family of instructions, which give you the upper 32-bit of a 32 by 32 multiplication. This would require a single 64-bit multiply, which is not available for our shader target, so I decided to emulate it using double-precision floating-point numbers for now. This is stupid.[<a href="#ref3" id="ref3b">3</a>]</p>

<p>The C version remains fully functional even now, and new features will still be implemented there first. It’s just <em>so much</em> easier to debug, plus compile times are magnitudes faster. The first porting effort happened even before it was able to boot Linux, I then gradually added support for more and more stuff by ping-ponging between the C and HLSL versions.</p>

<p><small id="ref2">[2] It is important to note that this quality has translated to HLSL too, I know for a fact that I gave some shader devs nightmares. <a href="#ref2b">⏎</a></small></p>

<p><small id="ref3">[3] Microsoft, please, I beg you, why would you add an instruction to DXIL but <a href="https://github.com/microsoft/DirectXShaderCompiler/issues/2821">not implement it in HLSL</a>?! <a href="#ref3b">⏎</a></small></p>

<hr>
<h1 id="whats-better-than-a-preprocessor">What’s better than a Preprocessor?</h1>

<p>That’s right, two of them!</p>

<p>Now that we have a C version up and running, one of the first challenges for porting it to a shader is state encoding and decoding. To make it more obvious why this is important, here is what our fragment shader will look like in the end (simplified):</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span>
    <span class="n">decode</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_Init</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cpu_init</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_TicksPerFrame</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cpu_tick</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">encode</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">decode()</code> logic takes care of intializing a global static <code class="language-plaintext highlighter-rouge">cpu</code> struct, <code class="language-plaintext highlighter-rouge">cpu_init()</code> or <code class="language-plaintext highlighter-rouge">cpu_tick()</code> update the state, and <code class="language-plaintext highlighter-rouge">encode()</code> writes it back.</p>

<p>This will run for every pixel in our state storage texture in parallel, and it’s the encoder’s job to pick which piece of information to write out in the end. Each pixel (that is, conceptually, every instance of this function running), can output 4 color values (R, G, B and Alpha) with 32 bits each, summing up to a total of 128 bit, or, more practically, 4 variables of our cpu struct.</p>

<p>What we need now is a mapping of pixel position and which state it contains. This must be consistent between <code class="language-plaintext highlighter-rouge">encode</code> and <code class="language-plaintext highlighter-rouge">decode</code> of course.</p>

<p><code class="language-plaintext highlighter-rouge">decode</code> will consist of a bunch of statements akin to:</p>
<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cpu</span><span class="p">.</span><span class="n">xreg1</span> <span class="o">=</span> <span class="n">STATE_TEX</span><span class="p">[</span><span class="n">uint2</span><span class="p">(</span><span class="mi">69</span><span class="p">,</span> <span class="mi">0</span><span class="p">)].</span><span class="n">r</span><span class="p">;</span>
</code></pre></div></div>

<p>…which will index the state texture at coordinates <code class="language-plaintext highlighter-rouge">x=69,y=0</code>, take the value stored in the red color channel and decode it as general purpose register (xreg) 1.</p>

<p><code class="language-plaintext highlighter-rouge">encode</code> looks like this:</p>
<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint</span> <span class="n">pos_id</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">x</span> <span class="o">|</span> <span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">pos_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">case</span> <span class="mi">69</span><span class="p">:</span>
        <span class="n">ret</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">.</span><span class="n">xreg1</span><span class="p">;</span>
        <span class="n">ret</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">.</span><span class="n">xreg2</span><span class="p">;</span>
        <span class="n">ret</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">.</span><span class="n">xreg3</span><span class="p">;</span>
        <span class="n">ret</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">.</span><span class="n">xreg4</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Yep, it’s just one massive switch/case statement. I can immediately hear people complain about performance here, since branching in shaders is generally a bad idea™. But in this case, the impact is minimal because of several reasons:</p>

<ul>
  <li>This is a switch statement, not a pure branch, which can actually compile down to a jump table for the final shader assembly, meaning the cost of the branch itself is constant</li>
  <li>In accordance with the first reason, more branches are avoided by packing the x and y coordinates into the same value (this works since our state texture is small)</li>
  <li>While it is true that branches which resolve to different values for neighboring pixels cause divergence (i.e. they break parallelism), this happens at the <em>very end</em> of our fragment shader, everything prior should still execute in a combined wavefront</li>
  <li>If you’re concerned about this single switch/case statement, boy do I have bad news for you about the rest of this shader</li>
</ul>

<hr>

<p>My immediate thought when I decided on this approach was that these lines look <em>very</em> regular. It would be a shame to write them all by hand.</p>

<p>At first I figured I could come up with some C preprocessor macros (which thankfully are supported in HLSL) to do the job for me. However, it turns out such macros are really bad at anything procedural, like counting up indices - or coordinates. So instead, I decided on using a seperate, external preprocessor: <a href="https://metacpan.org/dist/Text-PerlPP/view/bin/perlpp">perlpp</a>.</p>

<p>In all honesty, this was probably a big mistake in terms of code readability. But it <em>did</em> work super well for this specific case, and with the full power of Perl 5 for code gen, I could do some neat stuff.</p>

<p>This is how a struct is now defined:</p>
<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="o">&lt;?</span> <span class="err">$</span><span class="n">s</span><span class="o">-&gt;</span><span class="p">(</span><span class="s">"uint"</span><span class="p">,</span> <span class="s">"mmu.mode"</span><span class="p">);</span> <span class="o">?&gt;</span>
    <span class="o">&lt;?</span> <span class="err">$</span><span class="n">s</span><span class="o">-&gt;</span><span class="p">(</span><span class="s">"uint"</span><span class="p">,</span> <span class="s">"mmu.ppn"</span><span class="p">);</span> <span class="o">?&gt;</span>
<span class="p">}</span> <span class="n">mmu_state</span><span class="p">;</span>
</code></pre></div></div>
<p><small>(excerpt from <a href="https://github.com/PiMaker/rvc/blob/6208912/_Nix/rvc/src/types.h.pp#L103">types.h.pp</a>)</small></p>

<p>Ignoring the syntax highlighter completely freaking out (which happens in vim and VS code too, never got around to fixing that…), this looks fairly readable in my opinion. The <code class="language-plaintext highlighter-rouge">$s</code> perl function is defined to print a normal struct definition, but also store the name and type into a hash table. This can then later be used to auto-generate the <code class="language-plaintext highlighter-rouge">encode</code> and <code class="language-plaintext highlighter-rouge">decode</code> functions.</p>

<hr>

<p>We also know the last address that contains any state, which we can use to place other, more linear data right after. In particular, this includes the CSR-area. CSRs are “Control and Status Registers”, which are 4096 32-bit registers that can be accessed using specific instructions (<code class="language-plaintext highlighter-rouge">csrw</code>, <code class="language-plaintext highlighter-rouge">csrr</code>, <code class="language-plaintext highlighter-rouge">csrc</code>, etc.). They contain certain state about the CPU’s environment, like the active privilege mode, IRQ enablement or the MMU base pointer (<code class="language-plaintext highlighter-rouge">SATP</code>).</p>

<p>Aside from a few exceptions, these do not have special semantics on read and write, so it is enough to store them in a way that they can be indexed using their address. 4096 values means 1024 pixels, which we place 4-word aligned right after the last state-containing pixel. Reading now simply means calculating the offset from the CSR base (which is determined by <em>perlpp</em> at compile-time) and doing a texture tap. Writing happens via a similar caching mechanism as main memory, more on that later.</p>

<hr>

<p>In addition to all that, <em>perlpp</em> makes it possible to use loops in code-gen. This is tremendously helpful for dynamic sizing of caches and structs with many values (for example the 32 general purpose registers).</p>

<p>One of the many problems with shader code is that HLSL doesn’t support arrays in a meaningful way. Pointer math (and thus array indexing) just isn’t a thing on the GPU, so writing to a non-constant index of an array is impossible. To work around this, there are several places in the code with patterns like this:</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="o">&lt;?</span> <span class="k">for</span> <span class="n">my</span> <span class="err">$</span><span class="n">i</span> <span class="p">(</span><span class="mi">0</span><span class="p">..</span><span class="mi">31</span><span class="p">)</span> <span class="p">{</span>
        <span class="err">$</span><span class="n">s</span><span class="o">-&gt;</span><span class="p">(</span><span class="s">"uint"</span><span class="p">,</span> <span class="s">"xreg$i"</span><span class="p">);</span>
        <span class="n">print</span> <span class="s">"</span><span class="se">\n</span><span class="s">    "</span><span class="p">;</span>
    <span class="p">}</span> <span class="o">?&gt;</span>
    <span class="c1">// ...</span>
<span class="p">}</span> <span class="n">cpu_t</span><span class="p">;</span>

<span class="n">uint</span> <span class="nf">xreg</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#define C(x) case x: return cpu.xreg##x;
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="nb">flatten</span><span class="p">]</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">[</span><span class="nb">flatten</span><span class="p">]</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">28</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="n">C</span><span class="p">(</span><span class="mi">31</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mh">0xdeadc0de</span><span class="p">;</span>
    <span class="cp">#undef C
</span><span class="p">}</span>
</code></pre></div></div>
<p><small>(excerpt from <a href="https://github.com/PiMaker/rvc/blob/6208912/_Nix/rvc/src/types.h.pp#L187">types.h.pp</a>)</small></p>

<p>This function returns the content of general purpose register <code class="language-plaintext highlighter-rouge">i</code>, but since the registers are not an array, it has to use a (<code class="language-plaintext highlighter-rouge">[flatten]</code>ed) switch statement. The outer <code class="language-plaintext highlighter-rouge">if</code> is an optimization, so each call only needs to go through 16 <code class="language-plaintext highlighter-rouge">movc</code> instructions. <code class="language-plaintext highlighter-rouge">xreg</code> is called a lot, and considered one of the “inlineable” functions - that’s why I’m not using a <code class="language-plaintext highlighter-rouge">[forcecase]</code>-style jumptable here; but we’re getting way ahead of ourselves…</p>

<hr>
<h1 id="instruction-decoding-and-dxsc-bugs">Instruction Decoding and DXSC Bugs</h1>

<p>Now that we can keep the state stored, let’s take a look at what our fragment shader will do with it. From the simplified example above, <code class="language-plaintext highlighter-rouge">cpu_init</code> is almost not worth talking about, simply zeroing the <code class="language-plaintext highlighter-rouge">cpu</code> struct and setting some default values. <code class="language-plaintext highlighter-rouge">cpu_tick</code> is where the magic happens, and our fairly normal, linear emulation code lives.</p>

<p>After reading an instruction from the current program counter (<code class="language-plaintext highlighter-rouge">pc</code> register) address, we need to decode it. I decided to cheat a little for this:</p>

<p>I took a look at how the aforementioned <a href="https://github.com/takahirox/riscv-rust">riscv-rust</a> emulator handles that part, and quickly realized that the <code class="language-plaintext highlighter-rouge">INSTRUCTIONS</code> array in <code class="language-plaintext highlighter-rouge">src/cpu.rs</code> contains basically all information required for parsing. So I did what any sane person would, copied the entire array into a text file, wrote a little <a href="https://github.com/PiMaker/rvc/blob/64e2d0b/parse_ins.pl">perl script</a> and had it auto-generate the decoding logic for me.</p>

<p>The end result looks something like this:</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// definition:</span>
<span class="n">DEF</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">FormatR</span><span class="p">,</span> <span class="p">{</span> <span class="c1">// rv32i</span>
    <span class="n">NOT_IMPL</span>
<span class="p">})</span>
<span class="n">DEF</span><span class="p">(</span><span class="n">addi</span><span class="p">,</span> <span class="n">FormatI</span><span class="p">,</span> <span class="p">{</span> <span class="c1">// rv32i</span>
    <span class="n">NOT_IMPL</span>
<span class="p">})</span>
<span class="c1">// ... and many more</span>

<span class="c1">// decoding:</span>
<span class="n">ins_masked</span> <span class="o">=</span> <span class="n">ins_word</span> <span class="o">&amp;</span> <span class="mh">0xfe00707f</span><span class="p">;</span>
<span class="p">[</span><span class="nb">forcecase</span><span class="p">]</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">ins_masked</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RUN</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mh">0x00000033</span><span class="p">,</span> <span class="n">ins_FormatR</span><span class="p">)</span>
    <span class="n">RUN</span><span class="p">(</span><span class="n">and</span><span class="p">,</span> <span class="mh">0x00007033</span><span class="p">,</span> <span class="n">ins_FormatR</span><span class="p">)</span>
    <span class="n">RUN</span><span class="p">(</span><span class="n">div</span><span class="p">,</span> <span class="mh">0x02004033</span><span class="p">,</span> <span class="n">ins_FormatR</span><span class="p">)</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
<span class="n">ins_masked</span> <span class="o">=</span> <span class="n">ins_word</span> <span class="o">&amp;</span> <span class="mh">0x0000707f</span><span class="p">;</span>
<span class="p">[</span><span class="nb">forcecase</span><span class="p">]</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">ins_masked</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RUN</span><span class="p">(</span><span class="n">addi</span><span class="p">,</span> <span class="mh">0x00000013</span><span class="p">,</span> <span class="n">ins_FormatI</span><span class="p">)</span>
    <span class="n">RUN</span><span class="p">(</span><span class="n">andi</span><span class="p">,</span> <span class="mh">0x00007013</span><span class="p">,</span> <span class="n">ins_FormatI</span><span class="p">)</span>
    <span class="n">RUN</span><span class="p">(</span><span class="n">beq</span><span class="p">,</span> <span class="mh">0x00000063</span><span class="p">,</span> <span class="n">ins_FormatB</span><span class="p">)</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// etc.pp.</span>
</code></pre></div></div>
<p><small>(actual definition is in <a href="https://github.com/PiMaker/rvc/blob/6208912/_Nix/rvc/src/emu.h">emu.h</a>)</small></p>

<p>This logic appears fairly optimal to me, in the end there are 9 different switch statements for slightly different opcode masks. I tried to sort these so that the most frequent instructions are first, though as I will discuss in the <em>Inlining</em> section below, this wasn’t always possible.</p>

<p>Observant readers (hi there!) will have noticed the <code class="language-plaintext highlighter-rouge">[forcecase]</code> above the <code class="language-plaintext highlighter-rouge">switch</code> keywords. This attribute is important for performance, as it forces the shader compiler to emit a jump table instead of a bunch of individual branches (or conditional moves with <code class="language-plaintext highlighter-rouge">[flatten]</code>). Now, you may be asking yourself, “if this is so important for performance, why isn’t it the default?”. Truth is, <em>I have absolutely no idea.</em></p>

<p>Of course there are situations where it’s actually faster to <code class="language-plaintext highlighter-rouge">[flatten]</code>, as conditional moves can lead to less divergence, but I don’t get why <code class="language-plaintext highlighter-rouge">[branch]</code>, i.e. “make it a bunch of if-statements” exists.</p>

<p>Thing is, there doesn’t seem to be a limit for jump tables. I have a <em>lot</em> of them in this shader. <strong>However</strong>, if you look at the code in <a href="https://github.com/PiMaker/rvc/blob/6208912/_Nix/rvc/src/emu.h">emu.h</a>, you will see that some of the statements use an explicit <code class="language-plaintext highlighter-rouge">[branch]</code> - the explanation to this conundrum is as simple as it is dumb: If I put a <code class="language-plaintext highlighter-rouge">[forcecase]</code> there, it crashes the shader compiler.</p>

<p>I don’t know why, I never got any useful log output aside from a generic “IPC error”, and I haven’t heard of anyone else experiencing this - then again, how often do you write shader code in this style…</p>

<hr>

<p><code class="language-plaintext highlighter-rouge">&lt;rant&gt;</code></p>

<p>The point I want to make in this section, is that the DirectX Shader Compiler can be <em>very</em> dumb and I hate it and it should go hide in a corner and be ashamed. No offense to anyone working on it, but I’ve had instances where a <em>whitespace change</em> made the difference between the shader compiler crashing and a working output.</p>

<p>Even if it is working, writing such a large shader is not a joy. I get that register allocation is a hard problem, but if gcc and clang can compile the same program in C within <em>milliseconds</em>, why do I have to wait upwards of <strong>10 minutes</strong> for the HLSL version to compile?!</p>

<p>Remember when I said there was a good reason for keeping the C version around…</p>

<p><code class="language-plaintext highlighter-rouge">&lt;/rant&gt;</code></p>

<hr>
<h1 id="main-memory">Main Memory</h1>

<p>To run Linux, I figured we’d need at least 32 MiB of main memory (RAM), but let’s be safe and make that 64 - the performance difference will not be big, and there should be enough VRAM.</p>

<p>At first, the main performance concern was <em>clock speed</em>. That is, how many CPU cycles can run in one frame. Initially, I went with what seemed to be the simplest option available - let’s call this version 1:</p>

<ul>
  <li>64 MiB of RAM require a 2048x2048 pixel texture at 128 bit per pixel</li>
  <li>let’s reserve a small area in the top-left, say 128x128 for our CPU state</li>
  <li>have the shader run one tick per execution and write the result out, treating RAM the same as state - i.e. we run the fragment shader for <em>2048x2048 = 4194304</em> pixels</li>
</ul>

<p>This is obviously rather inefficient, and would ultimately result in a clock speed of 1 cycle per frame. We can somewhat tweak this by running the CRT (Custom Render Texture, or equivalent camera loop with Udon) multiple times per frame, but this incurs the hefty cost of double-buffering (and thus swapping) the entire 64 MiB texture every time. Instead, let’s leave this concept behind a bit and focus on version 2:</p>

<ul>
  <li>same 2048x2048 texture with 128x128 state area as before</li>
  <li>shader split into two passes: <code class="language-plaintext highlighter-rouge">CPUTick</code> does a CPU cycle but writes to a memory cache area within the 128x128 pixels, and <code class="language-plaintext highlighter-rouge">Commit</code> writes that cache back to RAM</li>
  <li>the Custom Render Texture is set up so it renders multiple times, first a bunch of <code class="language-plaintext highlighter-rouge">CPUTick</code> passes on <em>just the 128x128 area</em>, then it finishes up with a single full-texture <code class="language-plaintext highlighter-rouge">Commit</code></li>
</ul>

<p>This implementation already gets us a lot further. On the bright side, Unity is smart enough to realize that when you only update the 128 by 128 area, it also only needs to buffer swap this part of the texture. And since this area is fairly small, it fits entirely within the L2 cache of almost any modern GPU, making the swapping process very cheap. On the downside, this now means we need a seperate memory cache - no problem though, we have enough space left over in the state area to hold all the data we want.</p>

<p>Version 2 got up to around 35-40 kHz in-game, pretty decent, but still not fast enough for my liking. Enter the current version 3:</p>

<ul>
  <li>same area splitting as before, keep the two-pass design</li>
  <li>instead of multiple passes in the CRT, simply loop directly in the shader and run multiple ticks at once</li>
</ul>

<p>This option has the least non-compute overhead of all the above. There’s only two buffer swaps, and one of them is for the small area. This caching strategy (I call it the “L1 write cache”) is what makes this shader fast enough to run Linux. 300 kHz is not out of the question on a high-end GPU, my 2080 Ti regularly pushes over 200.</p>

<p><img src="../../assets/calc_pi.jpg" alt="pi calculated to 1234 places">
<small>(image credit: <a href="https://twitter.com/d4rkpl4y3r_vr">@d4rkpl4y3r_vr</a>, who had the patience to show that the emulator can calculate <em>pi</em> to 1234 places)</small></p>

<p>However, there is now a glaring issue: If we run multiple ticks per iteration, we cannot use the 128x128 px state area as a cache anymore. In a fragment shader, we can only write output at the end of execution, but memory writes can happen anytime during emulation, and <em>must be architecturally visible</em> immediately - that is, in RISC-V, a write followed by a read to the same address must always return the previously written value.[<a href="#ref4" id="ref4b">4</a>]</p>

<p>With this in mind, the L1 cache only has one place to live: The GPU’s register file. I’ve been told modern architectures should support up to 64 kB of instance state (I suppose it can evict to VRAM?), but in practice the limit you’re going to hit is once again the shader compiler. Use too many variables, and we’re back at waiting 15 minutes for an “IPC error”.</p>

<p>At the time of writing, L1 is a two-way set associative cache with 16 sets and 5 words per line[<a href="#ref5" id="ref5b">5</a>]. This comes out to 320 bytes per frame - with the current setup, a good GPU can push up to 4000 instructions per frame, and with <code class="language-plaintext highlighter-rouge">sw</code> (“store word”) being one of them, this cache will fill up in as little as 80. If the cache is full, the CPU stalls until the next <code class="language-plaintext highlighter-rouge">Commit</code>. A little trick is to double up the <code class="language-plaintext highlighter-rouge">Commit</code> passes and do two <code class="language-plaintext highlighter-rouge">CPUTick</code>s as well - that way we can at least get twice the throughput, while only incuring a moderate performance hit for buffer swapping the full 64 MiB twice.</p>

<p>This caching strategy is the tradeoff I made for clock speed - memory write performance absolutely <strong>sucks</strong>. But it’s decidedly faster than limiting the clockspeed itself, the “real-world” performance is certainly better this way.</p>

<hr>

<p>A neat little side-effect of storing main memory in a texture, is that you can display it visually! Below is a (jpeg-compressed and downsized) picture of the main memory with a fully booted linux kernel.</p>

<p>Notice the two large zeroed (black) areas at the top (128px state area + OpenSBI and reserved bootloader memory), and the fascinating blue memory pattern at the bottom (that’s the high addresses, I believe the regular stripes are due to early memory poisoning of the SLAB/SLUB allocator in the kernel, feel free to correct me on this):</p>

<p><img src="../../assets/rvc_ram.jpg" alt="RAM of linux kernel"></p>

<p>The texture is also on display in the VRChat world, where you can take a closer look during execution yourself. It’s quite fun to see memory framention visibly become worse, the more userspace programs are started.</p>

<hr>

<p>As an aside, you might be wondering why I called the cache “L1”, as in “Layer 1”. The reason is that in the future I’m planning on extending this concept to become a sort of hybrid between version 2 and 3. The idea is that there will be multiple ticks before a commit, each one being followed by a <code class="language-plaintext highlighter-rouge">Writeback</code> pass, that still only operates on the 128x128 texture (for cheap double-buffering) and flushes the L1 cache to a page-based L2 variant.</p>

<p>The tricky part here is that this has to go away from being set- or fully-associated, as both of these variants would not only incur massive performance penalties for lots of branching, but also for the repeated texture taps (as I can’t allocate any more registers for the L2 without crashing the compiler again). Instead, I’m planning on having only a few registers allocated that contain page base addresses that then point to a linear cache area in the state texture. This is somewhat hard to keep coherent though, and requires a new concept of stalling only until a <code class="language-plaintext highlighter-rouge">Writeback</code>, so I couldn’t get it done in time for the initial presentation.</p>

<p><small id="ref4">[4] an exception to this rule is instruction loading, which only needs to be consistent after a <code class="language-plaintext highlighter-rouge">fencei</code> instruction - we can make use of this by omitting the somewhat expensive cache-load logic for memory reads and just tap the texture directly, simply stalling the CPU on <code class="language-plaintext highlighter-rouge">fencei</code> until the next <code class="language-plaintext highlighter-rouge">Commit</code> since it is called very infrequently <a href="#ref4b">⏎</a></small></p>

<p><small id="ref5">[5] another benefit of perlpp: all of these values are configurable in a single <a href="https://github.com/PiMaker/rvc/blob/6208912/_Nix/rvc/src/header.p">“header” file</a> <a href="#ref5b">⏎</a></small></p>

<hr>
<h1 id="a-note-on-inlining">A Note on Inlining</h1>

<p>HLSL has the peculiarity that there are no function calls. <em>All</em> functions are inlined at the call site[<a href="#ref6" id="ref6b">6</a>], if you call a function four times, it will be included four times in the output assembly. This is of course recursive, so a function that calls other functions will also inline <em>those</em> at every callsite.</p>

<p>This doesn’t sound like a big issue, but it turns out it actually is - one of the biggest performance tricks I learned during development of the emulator, is that avoiding multiple callsites can improve performance quite a bit. I’m not 100% sure why that is, but I would assume it has to with locality/recency in the L1i cache of the GPU. So less code = less assembly = less thrashing in the instruction cache, and thus better performance.</p>

<p>Additionally, how could it be any different, it also helps with actually getting the thing to compile. More inlines means more code to translate, and the shader compiler <em>really hates</em> code.</p>

<p>This gives rise to some awkward optimizations, that would produce the opposite result almost anywhere else. The main example of this is coalescing memory reads and writes:</p>

<p>The C code simply calls <code class="language-plaintext highlighter-rouge">mem_get_word</code> in the execution path of each instruction. This works, because the function call is cheap. But if it were to be inlined in every instruction that reads from memory, it would slow down the shader a lot. Instead, we do it preventatively - before even executing the instruction-specific code, check by way of the opcode if the instruction <em>might</em> need to read a value from memory. If that is the case, figure out where from (which is different for regular <code class="language-plaintext highlighter-rouge">lX</code> and atomic ops), and load the memory once. This way, <code class="language-plaintext highlighter-rouge">mem_get_word</code> only needs to be inlined once for the entire instruction emulation path.</p>

<p>We also handle unaligned memory reads creatively. Off the top of my head, this would be the obvious solution:</p>
<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_addr</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">mem_get_word</span><span class="p">(</span><span class="n">read_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">3</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">off</span><span class="p">;</span>
<span class="n">val</span> <span class="o">|=</span> <span class="n">mem_get_word</span><span class="p">(</span><span class="n">read_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">off</span><span class="p">);</span>
</code></pre></div></div>

<p>…but instead, we use the one tool HLSL gives us to avoid multiple inlining, loops with the <code class="language-plaintext highlighter-rouge">[loop]</code> attribute that prevents them from being unrolled:</p>
<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint</span> <span class="n">w1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">[</span><span class="nb">loop</span><span class="p">]</span>
<span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">ui</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ui</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">read_addr</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span> <span class="n">ui</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">mem_get_word</span><span class="p">((</span><span class="n">read_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x3</span><span class="p">))</span> <span class="o">+</span> <span class="mh">0x4</span> <span class="o">*</span> <span class="n">ui</span><span class="p">);</span>
    <span class="p">[</span><span class="nb">flatten</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="p">)</span> <span class="p">{</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">w1</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">do_mem_read</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
<span class="n">val</span> <span class="o">|=</span> <span class="n">w2</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">do_mem_read</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">))</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
</code></pre></div></div>

<p>There are several places in the code that seemingly make no sense, but are actually intentionally written with the goal of avoiding inlining. Try to keep that in mind, if you dare read through the source yourself.</p>

<p><small id="ref6">[6] there is a <code class="language-plaintext highlighter-rouge">[call]</code> attribute for switch/case, but once again I don’t know why you wouldn’t just use <code class="language-plaintext highlighter-rouge">[forcecase]</code>, in my testing it unconditionally made performance worse - it does however actually compile to a jump and return, meaning the capability must exist in shader assembly, but even functions with <code class="language-plaintext highlighter-rouge">[noinline]</code> (which is a valid attribute) are always inlined… <a href="#ref6b">⏎</a></small></p>

<hr>
<h1 id="excursion-debug-view">Excursion: Debug View</h1>

<p>For debugging purposes, and later on also actual data extraction, we need a way to communicate values from our shader to the user. And ideally not just the enduser, but also Udon, where we can further process the data on the CPU. Udon does not expose <code class="language-plaintext highlighter-rouge">Graphics.Blit</code>, which is the usual Unity way of reading shader output to the CPU, so we need some trickery again.</p>

<p>The only way currently to get pixel data from a shader into Udon is via the <code class="language-plaintext highlighter-rouge">OnPostRender</code> callback. If the behaviour is on a <code class="language-plaintext highlighter-rouge">Camera</code> object, this will be called once per frame. Within it, <code class="language-plaintext highlighter-rouge">Buffer.ReadPixels</code> can be used to retrieve the actual pixel data into a Read/Write enabled static <code class="language-plaintext highlighter-rouge">Texture2D</code> object. The individual pixels can then be accessed as <code class="language-plaintext highlighter-rouge">Color</code> structs. But not so fast, a Unity <code class="language-plaintext highlighter-rouge">Color</code> contains four float values at 8-bit precision, and alpha is premultiplied - so simply reading our state/RAM texture which uses Integer-Format with 128 bpp is out of the question.</p>

<p>Instead, we write a secondary shader, a “helper” shader if you so will, that stretches the state texture (and only the state part, not the entire RAM) onto a seperate, floating-point enabled texture 6-times the width (and only using the 3 base color channels). Doing some “clever” floating-point math and bit-twiddling allows us to finally recover the original value.</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PACK_MASK 0xFF
#define PACK_SHIFT 8
</span><span class="kt">void</span> <span class="nf">pack_uint4</span><span class="p">(</span><span class="k">in</span> <span class="n">uint4</span> <span class="n">data</span><span class="p">,</span> <span class="k">out</span> <span class="kt">float3</span> <span class="n">result</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">rgb</span> <span class="o">&amp;</span> <span class="n">PACK_MASK</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">.</span><span class="n">rgb</span> <span class="o">&gt;&gt;</span> <span class="n">PACK_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PACK_MASK</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">.</span><span class="n">rgb</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PACK_SHIFT</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">PACK_MASK</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">.</span><span class="n">rgb</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PACK_SHIFT</span><span class="o">*</span><span class="mi">3</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">PACK_MASK</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">PACK_MASK</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">g</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">.</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">PACK_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PACK_MASK</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">b</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">.</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PACK_SHIFT</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">PACK_MASK</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">r</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">.</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PACK_SHIFT</span><span class="o">*</span><span class="mi">3</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">PACK_MASK</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">gb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#undef PACK_SHIFT
#undef PACK_MASK
</span></code></pre></div></div>
<p><small>(excerpt from <a href="https://github.com/PiMaker/rvc/blob/6208912/_Nix/rvc/helpers.cginc">helpers.cginc</a>, for encoding)</small></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">MULT</span> <span class="p">=</span> <span class="m">255.0f</span><span class="p">;</span>
<span class="k">private</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">ADD</span> <span class="p">=</span> <span class="m">0.5f</span><span class="p">;</span>
<span class="k">private</span> <span class="kt">uint</span> <span class="nf">decodePackedData</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Color</span><span class="p">[]</span> <span class="n">col</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Color</span><span class="p">[</span><span class="m">6</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">Buffer</span><span class="p">.</span><span class="nf">GetPixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
        <span class="n">Buffer</span><span class="p">.</span><span class="nf">GetPixel</span><span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="m">128</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
        <span class="n">Buffer</span><span class="p">.</span><span class="nf">GetPixel</span><span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="m">128</span><span class="p">*</span><span class="m">2</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
        <span class="n">Buffer</span><span class="p">.</span><span class="nf">GetPixel</span><span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="m">128</span><span class="p">*</span><span class="m">3</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
        <span class="n">Buffer</span><span class="p">.</span><span class="nf">GetPixel</span><span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="m">128</span><span class="p">*</span><span class="m">4</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
        <span class="n">Buffer</span><span class="p">.</span><span class="nf">GetPixel</span><span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="m">128</span><span class="p">*</span><span class="m">5</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="m">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span><span class="kt">uint</span><span class="p">)(</span><span class="n">col</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">r</span> <span class="p">*</span> <span class="n">MULT</span> <span class="p">+</span> <span class="n">ADD</span><span class="p">)</span> <span class="p">|</span>
                <span class="p">((</span><span class="kt">uint</span><span class="p">)(</span><span class="n">col</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">r</span> <span class="p">*</span> <span class="n">MULT</span> <span class="p">+</span> <span class="n">ADD</span><span class="p">)</span> <span class="p">&lt;&lt;</span> <span class="m">8</span><span class="p">)</span> <span class="p">|</span>
                <span class="p">((</span><span class="kt">uint</span><span class="p">)(</span><span class="n">col</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">r</span> <span class="p">*</span> <span class="n">MULT</span> <span class="p">+</span> <span class="n">ADD</span><span class="p">)</span> <span class="p">&lt;&lt;</span> <span class="m">16</span><span class="p">)</span> <span class="p">|</span>
                <span class="p">((</span><span class="kt">uint</span><span class="p">)(</span><span class="n">col</span><span class="p">[</span><span class="m">3</span><span class="p">].</span><span class="n">r</span> <span class="p">*</span> <span class="n">MULT</span> <span class="p">+</span> <span class="n">ADD</span><span class="p">)</span> <span class="p">&lt;&lt;</span> <span class="m">24</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><small>(excerpt from <a href="https://github.com/PiMaker/rvc/blob/6208912/_Nix/NixDebug.cs">NixDebug.cs</a>, for decoding - this file is in desperate need of a cleanup :/)</small></p>

<p><img src="../../assets/rvc_debug_display.jpg" alt="debug view in-game">
<small>(the debug display as seen in-game, the spherical buttons allow for single-stepping)</small></p>

<p>This is fairly expensive, especially since it’s running in Udon, so we limit the rendering of this <code class="language-plaintext highlighter-rouge">Camera</code> to once every 15 frames or so. Certainly not pretty, but works well enough for debugging (and unfortunately also some device state).</p>

<hr>
<h1 id="mmu-and-devices">MMU and Devices</h1>

<p>The emulator includes a full SV32 memory management unit. I didn’t even plan on adding this at first, but it turns out Linux only supports NOMMU mode on 64-bit RISC-V. I suppose this project is a fairly niche use-case…</p>

<p>Fortunately, this ended up being easier than expected. I’m not sure what it was about the MMU, but it sounded quite difficult at first, only to turn out to be a straightforward implementation of the paging algorithm described in the <em>RISC-V privileged spec</em>.</p>

<p>Once again, the two-layer pagewalk is performed with avoiding inlining in mind. The <code class="language-plaintext highlighter-rouge">load_page</code> function only has one callsite, with the recursive walk taken care of by a loop. I felt that the MMU logic was optimized enough that I could get away with using <code class="language-plaintext highlighter-rouge">mem_get_cached_or_tex</code>, which includes the cache logic - this means that page tables are fully coherent, and <code class="language-plaintext highlighter-rouge">sfence.vma</code> (what would be a TLB flush on x86) can be a no-op.</p>

<hr>

<p>There are two devices on the emulated SoC that can issue interrupts - the CLINT timer and the UART. Additionally, software interrupts into both machine and supervisor mode are supported as well. All of this is covered under the umbrella term “trap handling”, which deals with IRQs and exceptions. <a href="https://github.com/PiMaker/rvc/blob/6208912/_Nix/rvc/src/trap.h">Most of this logic</a> is borrowed fairly directly from <em>riscv-rust</em> again, with the exception being that PLIC and CLINT are handled all at once.[<a href="#ref7" id="ref7b">7</a>]</p>

<p>The timer’s frequency is in sync with the CPU clock, i.e. one clock cycle equals one timer tick. That being said, this is not what our <a href="https://github.com/PiMaker/rvc/blob/17da347/dts.dts">device tree</a> is communicating to Linux. The frequency given as <code class="language-plaintext highlighter-rouge">timebase-frequency = &lt;0x1000000&gt;;</code> ranges in the MHz, obviously way faster than what it actually runs at. I’m not entirely certain why that is necessary, but if I set this to a more natural 200 kHz-ish, Linux schedules it’s own timer interrupt so frequently as to completely stall the boot process.</p>

<p>The UART is a bit more tricky: While the emulator-facing side is a fairly simple 8250/16550a serial port, it also needs to communicate data out to the user and read inputs.</p>

<p>Output is currently handled via a ring-buffer that is shared with Udon using the same mechanism as the <em>Debug View</em> mentioned above. Udon then simply puts the characters to a Unity UI <code class="language-plaintext highlighter-rouge">Canvas</code>. I plan on replacing this with a fully shader-based terminal renderer in the future, this would also allow me to properly implement ANSI/VT100 escape codes - <code class="language-plaintext highlighter-rouge">vim</code> vs <code class="language-plaintext highlighter-rouge">emacs</code> live debate in VRChat anyone?</p>

<p><img src="../../assets/uart_output_bug.jpg" alt="UART bug showing ninux and bnnutils">
<small>(a bug in the UART output causing me to boot the knockoff “ninux” built with “GNU Bnnutils”)</small></p>

<p>Input is rather simple too, using a regular shader parameter to pass the input ASCII character from Udon (specifically a modified version of <a href="https://github.com/FairlySadPanda/UdonStringEvents">@FairlySadPanda’s Keyboard script</a>) to the shader. It also needs the <em>Debug View</em> mechanism however, since the guest running in the emulator might not acknowledge the received character, in which case it will remain in the buffer and <code class="language-plaintext highlighter-rouge">RBR</code> will stay set. This of course also limits input speed to how often we decide to render the performance-hungry debug <code class="language-plaintext highlighter-rouge">Camera</code>.</p>

<p>There is currently no disk emulated, since VRChat doesn’t support world persistancy at the moment anyway. Linux boots entirely from RAM, the initramfs stays mounted as the rootfs.</p>

<p><small id="ref7">[7] Side-note that I mention for no particular reason and definitely didn’t spend a full day tracking down a related bug on: Did you know that bitwise negate in Rust is <code class="language-plaintext highlighter-rouge">!</code>, which, if copied to C, will compile successfully and without warning, but actually perform a <em>boolean</em> negate? Now you do! <code class="language-plaintext highlighter-rouge">~</code> is what you need, obviously. <a href="#ref7b">⏎</a></small></p>

<hr>
<h1 id="payloads">Payloads</h1>

<p>Speaking of the initramfs, compiling software to run on the emulator is suprisingly straightforward. I used <a href="https://buildroot.org/">Buildroot</a> to generate a riscv32 GNU toolchain for cross-compiling on my host, and also to generate a cpio image containing <a href="https://www.busybox.net/">BusyBox</a>, <a href="https://bellard.org/quickjs/">QuickJS</a> and my little <code class="language-plaintext highlighter-rouge">init</code> script to print a neat ASCII art logo.</p>

<p>The kernel itself is version <em>5.13.5</em>, which was the latest stable before the presentation. It runs completely stock with an <code class="language-plaintext highlighter-rouge">allnoconfig</code> and only configuring what’s absolutely necessary, but I did patch in a few tweaks. At the moment, these consist of:</p>

<ul>
  <li>Not poisoning boot memory, as that takes too long and is mostly for security (which, as you might have guessed, does <em>not</em> have the highest priority in this project)</li>
  <li>Printing more information during initramfs loading (as otherwise it just looks like it got stuck for a while; did I mention memory write/copy is really slow?)</li>
  <li>Currently disabled, but for future use a paravirtualized <code class="language-plaintext highlighter-rouge">memcpy</code> implementation, that uses custom CSR registers to copy memory in the <code class="language-plaintext highlighter-rouge">Commit</code> stage instead of going through L1 cache</li>
</ul>

<p>I have a prototype of the last point working now, but before the presentation some last-minute bugs prevented me from showing it off.</p>

<p>Of course, Linux is not the only thing that runs on the emulator. The <a href="https://github.com/pimaker/rvc#build-instructions-for-the-various-subprojectspayloads">GitHub</a> has some instructions on how to build other payloads. Aside from a very basic bare-metal C program to test functionality, the two more interesting ones are <strong>Micropython</strong> and <strong>Rust-Test</strong>.</p>

<p>The first one, <a href="https://micropython.org/">Micropython</a>, provides a Python 3 REPL where you can experiment with writing your own code live in VRChat. The benefit of it being that it boots way quicker than Linux. I had to add a riscv32 port myself, based on the existing riscv64 version, it certainly isn’t the cleanest but it boots and does what it’s supposed to showcase.</p>

<p><img src="../../assets/sirpinski.jpg" alt="Micropython with sierpiński triangle">
<small>(image credit: <a href="https://github.com/pema99">@pema99</a>, a sierpiński triangle rendered with Micropython)</small></p>

<p>The <strong>Rust-Test</strong> or <strong>rust_payload</strong> program is my experiment in building native, <code class="language-plaintext highlighter-rouge">no-std</code> Rust for use on the emulator. I needed to patch the <code class="language-plaintext highlighter-rouge">rustc</code> compiler to not emit compressed instructions (which are not implemented, as decoding them would only take more assembly-space and RAM is actually the one resource we have more than enough of). This was among the first things to run successfully on the emulator!</p>

<p>This one gave me some interesting ideas for potential future use-cases as well. Imagine having an interface to call Unity functions from the emulator (e.g. via the previously mentioned debug interface), and then writing your world scripts in Rust. Probably too slow to be useful, but an intriguing concept.</p>

<p>And just to have it noted, all payloads (aside from the bare-metal test) run on top of OpenSBI, which, if you’re coming from x86 you can think of as sort of a “BIOS” or “firmware”. It runs in machine mode, handles basic initialization tasks and prepares the environment for the stage-2 payload. It also provides some functionality to the next stage running in supervisor mode, most importantly timer scheduling (which requires machine privileges) and a basic UART driver (really useful in the Rust-Demo, as we can print to the console easily using it).</p>

<p><img src="../../assets/opensbi_wink.jpg" alt="OpenSBI with my avatar">
<small>(me standing in front of OpenSBI in VR for the first time)</small></p>

<hr>
<h1 id="the-end">The End?</h1>

<p>This was a big project for me, spanning over several months and bringing together many areas of knowledge I had aquired so far.</p>

<p>During development, I kept this project a secret for the longest time - I just love the thrill and payoff that comes with presenting something that absolutely nobody expected to see. Making this in VRChat has not only provided an additional challenge to overcome, but also brought with it the potential of demonstrating this live, in front of an audience, and then continue to chat with talented creators from all over. I thank everyone that answered my sometimes cryptic requests on Discord and in VRChat itself, and also everyone that didn’t ask what I was even working on when I frustratedly vented about something (probably the shader compiler) again.</p>

<p>This project has given me the opportunity to learn about the inner workings of RISC-V, it taught me more about the Linux Kernel’s boot process and hardware interface than most people would want to know, and it gave me an excuse to dive deeper and deeper into the magical world of shaders.</p>

<p>Once again, feel free to read the full code on <a href="https://github.com/pimaker/rvc">GitHub</a>, or check out the world for yourself in <a href="https://vrchat.com/home/world/wrld_8126d9ef-eba5-4d49-9867-9e3c4f0b290d">VRChat</a> - I’m always happy to chat in person, if you manage to catch me there :)</p>

<p>I’ll probably continue working on this project for a while, I still have a bunch of ideas at the ready. Maybe, just maybe, I’ll even write more blog posts about it.</p>

<p>So until next time,</p>

<p><em>~ _pi_</em></p>


</article>

      </main>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>

    // Highlight search Query
    var url = window.location.href;
      if (url.lastIndexOf("?q=") > 0) {
        // get the index of the parameter, add three (to account for length)
        var stringloc = url.lastIndexOf("?q=") + 3;
        // get the substring (query) and decode
        var searchquery = decodeURIComponent(url.substr(stringloc));
        // regex matches at beginning of line, end of line or word boundary, useful for poetry
        var regex = new RegExp("(?:^|\\b)(" + searchquery + ")(?:$|\\b)", "gim");
        // get, add mark and then set content
        var content = document.getElementById("main").innerHTML;
        document.getElementById("main").innerHTML = content.replace(regex, "<mark>$1</mark>");
      }

      // Toggle sidebar
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             !sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  

<iframe scrolling="no" frameborder="0" allowtransparency="true" src="https://platform.twitter.com/widgets/widget_iframe.8f764d5bd2778f88121d31d7d8d8e1e3.html?origin=https%3A%2F%2Fblog.pimaker.at" title="Twitter settings iframe" style="display: none;"></iframe></body></html>
