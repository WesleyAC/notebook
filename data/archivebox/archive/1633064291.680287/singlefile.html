<!DOCTYPE html> <html lang="en"><!--
 Page saved with SingleFile 
 url: https://scattered-thoughts.net/writing/things-unlearned/ 
 saved date: Fri Oct 01 2021 05:01:41 GMT+0000 (Coordinated Universal Time)
--><head><meta charset="utf-8"><meta content="IE=edge" http-equiv="X-UA-Compatible"><meta content="width=device-width,initial-scale=1.0" name="viewport"><title> Things unlearned </title><link href="https://scattered-thoughts.net/writing/things-unlearned/" rel="canonical"><link title="Scattered Thoughts" href="https://scattered-thoughts.net/atom.xml" rel="alternate" type="application/atom+xml"><style>hr{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,footer,nav{display:block}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}strong{font-weight:bolder}h1{margin:.67em 0}svg:not(:root){overflow:hidden}hr{box-sizing:content-box}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans,Georgia,serif;font-size:20px}.container{max-width:45em;margin:0 auto}body blockquote{border-left:2px solid #333333!important}html{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans,Helvetica,sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em}article h2{margin-top:4em}h3{text-align:center;font-size:1em;margin:0em}nav a,nav a:visited{text-decoration:none;color:#333333}a,a:visited,a:active{color:#0085a1}a:hover{color:#0085a1!important}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}ul{padding:0}ul{padding-left:30px;list-style:disc}footer{margin-top:4em;text-align:center;font-style:italic}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right,rgba(0,0,0,0),rgba(0,0,0,0.75),rgba(0,0,0,0))}.spacer-1{padding:0.5em}</style><link rel="shortcut icon" href="data:image/vnd.microsoft.icon;base64,AAABAAEAEBAAAAAAAABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUDAAAFAwAABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAwAABQMABAUDAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUDAAQFAwAEBQMABAUDAAQFAwAEBQMABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAwAEBQMABAAAAAAFAwD/BQMA/wUDAAAFAwAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQMABAUDAAAFAwD/BQMA/wUDAP8FAwD/BQMAAAUDAAQFAwAABQMAAAAAAAAAAAAABQMAAAUDAAAAAAAAAAAAAAUDAAAFAwD/BQMAAAAAAAAAAAAABQMAAAUDAP8FAwAABQMAAAUDAAAAAAAABQMAAAUDAAAFAwAABQMAAAUDAAAFAwD/BQMAAAAAAAAAAAAAAAAAAAAAAAAFAwACBQMA/wUDAAIAAAAABQMAAAAAAAAFAwD/BQMA/wUDAAAFAwAABQMAAAAAAAAAAAAAAAAAAAAAAAAFAwAABQMAAgUDAAIFAwACBQMAAgAAAAAFAwD/BQMA/wUDAP8FAwD/AAAAAAAAAAAAAAAAAAAAAAUDAAIFAwAABQMAAgUDAAIFAwACBQMAAgUDAAIFAwD/BQMAAgAAAAAAAAAABQMAAAUDAP8AAAAAAAAAAAAAAAAFAwACBQMAAgUDAAIFAwD/BQMA/wUDAAAFAwACBQMAAgUDAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAwAABQMAAgAAAAAFAwDyBQMA/wUDAP8FAwD/BQMAAAUDAAIFAwACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUDAAIFAwDyAAAAAAAAAAAAAAAABQMAAgUDAP8FAwACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAwDyAAAAAAAAAAAAAAAABQMAAgUDAAIFAwACBQMA/wUDAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQMAAgUDAAIFAwAAAAAAAAUDAAIFAwACBQMAAgUDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUDAAAFAwAABQMAAAUDAAAFAwAABQMAAAUDAAAFAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQMAAAAAAAAAAAAA//8AAP//AAD//wAA5/8AAMP/AAC9/wAAfvMAAP/hAAD/3gAA/P8AAPh/AAD3vwAA798AAP//AAD//wAA//8AAA==" type="image/x-icon"><meta http-equiv="content-security-policy" content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:;"></head><body><div class="container"><nav style="position:absolute;left:1em;top:1em"><a href="https://scattered-thoughts.net/"> <svg style="enable-background:new 0 0 547.596 547.596" viewBox="0 0 547.596 547.596" height="2em" id="Capa_1" version="1.1" width="2em" x="0px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" y="0px"> <g> <path d="M540.76,254.788L294.506,38.216c-11.475-10.098-30.064-10.098-41.386,0L6.943,254.788 c-11.475,10.098-8.415,18.284,6.885,18.284h75.964v221.773c0,12.087,9.945,22.108,22.108,22.108h92.947V371.067 c0-12.087,9.945-22.108,22.109-22.108h93.865c12.239,0,22.108,9.792,22.108,22.108v145.886h92.947 c12.24,0,22.108-9.945,22.108-22.108v-221.85h75.965C549.021,272.995,552.081,264.886,540.76,254.788z"></path> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> </svg> </a></nav><h1>Things unlearned</h1><div style="text-align:center;margin-top:-1.8em;font-style:italic;font-weight:light;font-size:0.7em">Last updated 2021-09-29</div><article><p><em>This post is part of a series, starting at <a href="https://scattered-thoughts.net/writing/reflections-on-a-decade-of-coding">Reflections on a decade of coding</a>.</em></p><p>This is one of my favorite questions to ask people: what are some things that you used to strongly believe but have now changed your mind about?</p><p>I want to focus especially on ideas that I wasted a lot of time on, or that got in the way of success.</p><h2 id="everyone-is-doing-it-wrong">Everyone is doing it wrong</h2><blockquote><p>Computing spread out much, much faster than educating unsophisticated people can happen. In the last 25 years or so, we actually got something like a pop culture, similar to what happened when television came on the scene and some of its inventors thought it would be a way of getting Shakespeare to the masses. But they forgot that you have to be more sophisticated and have more perspective to understand Shakespeare. What television was able to do was to capture people as they were. So I think the lack of a real computer science today, and the lack of real software engineering today, is partly due to this pop culture.</p></blockquote><blockquote><p>[...] the only programmers in a position to see all the differences in power between the various languages are those who understand the most powerful one. You can't trust the opinions of the others, because of the Blub paradox: they're satisfied with whatever language they happen to use, because it dictates the way they think about programs.</p></blockquote><blockquote><p>[...] clearly revolutionizes software as most know it. It could lead to efficient, reliable applications. But that won't happen. A mainstay of our economy is the employment of programmers. A winnowing by factor 100 is in no one's interest. Not the programmers, the companies, the government. To keep those programmers busy requires clumsy languages and bugs to chase.</p></blockquote><blockquote><p>[...] the reason we are facing bugs that kill people and lose fortunes, the reason that we are facing a software apocalypse, is that too many programmers think that schedule pressure makes it OK to do a half-assed job.</p></blockquote><p>It's easy to find examples of this idea, that everyone is doing computers completely wrong and that there exist simple solutions (and often that everyone else is just too lazy/stupid/greedy/immoral to adopt them).</p><p>X is amazing, so why isn't everyone using it? They must be too lazy to learn new things. Y is such a mess, why didn't they just build something simple and elegant instead. They must just be corporate jobsworths who don't care about quality. Why are all those researchers excited about Z? They just don't understand what the real world is like from up in their ivory tower.</p><p>It's not limited to programming, of course:</p><blockquote><p>Instead of losing faith in the power of government to work miracles, people believed that government could and should be working miracles, but that the specific people in power at the time were too corrupt and stupid to press the "CAUSE MIRACLE" button which they definitely had and which definitely would have worked. And so the outrage, the protests - kick these losers out of power, and replace them with anybody who had the common decency to press the miracle button!</p></blockquote><blockquote><p>-- <a href="https://astralcodexten.substack.com/p/book-review-the-revolt-of-the-public">Book review: the revolt of the public</a></p></blockquote><p>It's so easy to think that simple solutions exist. But if you look at the history of ideas that actually worked, they tend to only be simple from a distance. The closer you get, the more you notice that the working idea is surrounding by a huge number of almost identical ideas that don't work.</p><p>Take bicycles, for example. They seem simple and obvious, but it took <a href="https://en.wikipedia.org/wiki/History_of_the_bicycle">two centuries</a> to figure out all the details and most people today <a href="https://link.springer.com/content/pdf/10.3758/BF03195929.pdf">can't actually locate the working idea</a> amongst its neighbours.</p><p>Even when old niche ideas make a comeback (eg neural networks) it's not because they were right all along but because someone recognized the limitations and found a new variation on the idea that overcame them (eg deep learning).</p><p>I imagine some fans of the penny farthing groused about how everyone else was just too lazy or cowardly to ride them. But widespread adoption of bicycles didn't come from some general upswelling of moral fortitude. It came from someone figuring out a design that was less prone to firing the rider into the ground headfirst whenever they hit a bump.</p><p>Finding the idea that actually works amidst the sea of very similar ideas that don't work requires staying curious long enough to encounter the fine-grained detail of reality and humble enough to recognize and learn from each failure.</p><p>It's ok to think that things have flaws or could be improved. But it's a trap to believe that it's ever the case that a simple solution exists and everyone else is just too enfeebled of character to push the miracle button. All the miracle buttons that we know about have already been pressed.</p><p>I learned this the hard way at <a href="http://witheve.com/">Eve</a>. Starting from my very <a href="https://web.archive.org/web/20140111081750/http://scattered-thoughts.net/blog/2013/12/12/no-more-bullshit/">earliest writing about it</a> there was a pervading idea that we were going to revolutionize everything all at once. It took me two years to gradually realize that we were just hopping from one superficial idea to another without making any progress on the fundamental problems.</p><p>I remember at one early point estimating that it would take me two weeks to put together a reasonable query planner and runtime. The first time I even came close to success on that front was <a href="https://scattered-thoughts.net/writing/a-practical-relational-query-compiler-in-500-lines/">3 years later</a>. Similarly for incremental maintenance, which I'm <a href="https://github.com/jamii/dida/blob/main/docs/why.md">still figuring out</a> 7 years later.</p><p>It's not that our ideas were bad. It's just that we assumed so strongly that the problems must be simple that we kept looking for simple solutions instead of making use of the tools that were available, and we kept biting off more than we could chew because we didn't believe that any of the problems would take us long to solve.</p><p>Contemporaries like <a href="https://www.airtable.com/">airtable</a> instead started by solving an appropriately-sized subset of the problem and putting in the years of work to progressively fill in all the tiny details that make their solution actually useful. Now they're in a solid position to keep <a href="https://www.airtable.com/product/automations">chipping</a> <a href="https://www.airtable.com/product/sync">away</a> at the rest of the problem.</p><h2 id="programming-should-be-easy">Programming should be easy</h2><p>A similar trap hit often got me on a smaller scale. Whenever I ran up against something that was ugly or difficult, I would start looking for a simpler solution.</p><p>For example when I <a href="https://web.archive.org/web/20180611020249/https://github.com/jamii/inkling">tried to make a note-taking app for tablets</a> many years ago I had to make the gui, but gui tools are always kind of gross so I kept switching to new languages and libraries to try to get away from it. In each successive version I made less and less progress towards actually building the thing and had to cover more and more unknown ground (eg qtjava relies on using reflection to discover slots and at the time was difficult to implement the correct types from clojure). I wasted many hours and never got to take notes on my tablet.</p><p>If you have a mountain of shit to move, how much time should you spend looking for a bigger shovel? There's no obviously correct answer - it must depend on the size of the mountain, the availability of large shovels, how quickly you have to move it etc. But the answer absolutely cannot be 100% of your time. At some point you have to shovel some shit.</p><p>I definitely feel I've gotten better at this. When I wanted to <a href="https://github.com/jamii/focus">write a text editor</a> last year I spent a few days learning the absolute basics of graphics programming and text rendering, used mostly mainstream tools like sdl and freetype, and then just sat down and shoveled through a long todo list. In the end it only took 100 hours or so, much less time than I spent thrashing on that note-taking app a decade ago. And now I get to use my text editor all the time.</p><p>Sometimes the mountain isn't actually as big as it looks. And the nice thing about shoveling shit is that you get a lot faster with practice.</p><h2 id="the-new-thing">The new thing</h2><p>As a corollary to searching for the easy way, I've always been prone to spending far too much time on new or niche ideas. It's usually programming languages that get me, but I see other people do the same with frameworks, methodologies or architectures too. If you're really attracted to novelty you can spend all your time jumping between new things and never actually engage with the mainstream.</p><p>Mainstream ideas are mainstream for a reason. They are, almost by definition, the set of ideas which are well understood and well tested. We know where their strengths are and we've worked out how to ameliorate their weaknesses. The mainstream is the place where we've already figured out all the annoying details that are required to actually get stuff done. It's a pretty good place to hang out.</p><p>Of course there is value in exploring new ideas, but to be able to sift through the bad ideas and nurture the good ones you have to already thoroughly understand the existing solutions.</p><p>For example, at Eve I didn't read any of the vast literature on standard approaches to SQL query planning. I only looked at niche ideas that promised to be simpler or better, despite being completely untested (eg <a href="https://dl.acm.org/doi/pdf/10.1145/2967101">tetris-join</a>). But even after implementing some hot new idea I couldn't tell if it was good or bad because I had no baseline to compare it to. Whereas a group that deeply understands the existing tools can take a new idea like <a href="https://arxiv.org/abs/1210.0481">triejoin</a> and <a href="http://www.vldb.org/pvldb/vol13/p1891-freitag.pdf">compare it to the state of the art</a>, understand its strengths and weaknesses and use it appropriately.</p><p>I also remember long ago dismissing people who complained that some hot new niche language was missing a debugger. At the time I did that because I didn't see the need for a debugger when you could just reason about code algebraically. But in hindsight, it was also because I had never used a debugger in anger, had never watched anyone using a debugger skillfully and had never worked on a project whose runtime behavior was complicated enough that a debugger would be a significant aid. And all of that was because I'd spent all my time in niche languages and instead of becoming fluent in some ecosystem with mature tooling like java or c#.</p><p>The frontier is the place to go mining for new ideas, but it's 1% gold and 99% mud. And if you live your whole life there you'll never know what indoor plumbing is like and you'll find yourself saying things like "real programmers don't need toilet paper".</p><h2 id="learning-x-will-make-you-a-better-programmer">Learning X will make you a better programmer</h2><p>For the most popular values of X, I haven't found this to be true.</p><p>I think these claims are a lot like how people used to say that <a href="https://www.inc.com/jeff-haden/why-we-should-all-learn-to-speak-latin.html">learning latin makes you smarter</a>. Sure, learning things is fun. And various bits of knowledge are often useful within their own domain. But overwhelmingly, the thing that made me better at programming was doing lots of programming, and especially working on problems that pushed the limits of my abilities.</p><h3 id="languages">Languages</h3><p>The first language I learned was haskell and for several years I was devoted to proclaiming its innate superiority. Later on I wrote real production code in ocaml, erlang, clojure, julia and rust. I don't believe any of this improved my programming ability.</p><p>That's not to say that languages don't matter. Languages are tools and tools can be better or worse. And there has certainly been substantial progress in language design over the history of computing. But I didn't find that any of the languages I learned had a special juice that rubbed off on my brain and made me smarter.</p><p>If anything, my progress was often hampered by the lack of libraries, unreliable tools and not spending enough time in any one ecosystem to develop real fluency. These got in the way of working on hard problems, and working on hard problems was the main thing that actually led to improvement.</p><p>By way of counter-example, check out <a href="https://tonsky.me/blog/icfpc-2021/">this ICFP contest retrospective</a>. Nikita is using clojure, a pretty niche language, but has built up incredible fluency with both the language and the ecosystem so that he can quickly throw out web scrapers and gui editors. Whereas I wouldn't be able to quickly solve those problems in <strong>any</strong> language after flitting around from ecosystem to ecosystem for 12 years.</p><p>(See also <a href="https://danluu.com/boring-languages/">A defense of boring languages</a>, <a href="https://matklad.github.io/2020/09/13/your-language-sucks.html">Your language sucks, it doesn't matter</a>)</p><h3 id="functional-programming">Functional programming</h3><p>(Specifically as it appears in haskell, clojure, elm etc.)</p><p>I <strong>do</strong> find it useful to try to organize code so that most functions only look at their explicit inputs, and don't mutate those inputs. But I tend to do that with arrays and hashtables, rather than the pointer-heavy immutable structures typically found in functional languages. The latter imposes a low performance ceiling that makes many of the problems I work on much harder to solve.</p><p>The main advantage I see in functional programming is that it encourages tree-shaped data, one-way dataflow and focusing on values rather than pointer identity. As opposed to the graph-of-pointers and spaghetti-flow common in OOP languages. But you can just learn to write in that style without needing to wear the hair shirt. And I find it most useful at a very coarse scale (eg like <a href="https://bitsquid.blogspot.com/2011/01/managing-coupling.html">this</a> or <a href="https://bitsquid.blogspot.com/2009/12/events.html">this</a>). Within the scope of a single component/subsystem mutation is typically pretty easy to keep under control and often very useful.</p><h3 id="lambda-calculus-category-theory-automata">Lambda calculus / category theory / automata / ...</h3><p>Certain areas of maths and computer science attract a completely inappropriate degree of mystique. But, like languages, bodies of theory are tools that have a specific use.</p><ul><li>Lambda calculus is useful mainly as a simple standard language for explaining new PL ideas. You need to be familiar with it only if you want to read or write PL papers.</li><li>Automata theory and language classes are only really useful if you're trying to expand the state of the art (eg inventing <a href="https://github.com/tree-sitter/tree-sitter">treesitter</a>). Even though I write parsers all the time, in practice what I need to remember is a) write recursive descent parsers (like <a href="https://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html">most major language implementations</a>) b) google "pratt parsing" when dealing with operator precedence.</li><li>Category theory is the only undergrad class I regret, a hundred or so hours of my life that has yet to find a single plausible application.</li></ul><p>On the other hand, there are much less sexy areas that have been consistently useful throughout my entire career:</p><ul><li>Very basic probability and statistics, in many disparate areas eg doing performance estimates, analyzing system behavior, designing experiments, making decisions in life in general.</li><li>Having even the most basic <a href="https://www.google.com/search?q=fisher-price+kitchen&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=2ahUKEwjh8e3u26XzAhUYpZ4KHRKOBh0Q_AUoAXoECAEQAw&amp;biw=956&amp;bih=1041&amp;dpr=1">Fisher-Price</a> model of how hardware works makes it much easier to write fast software.</li><li>Being fluent in the core language of mathematics (basic logic, sets, functions, proof techniques) makes it easy to pick up domain-specific tools when I need them eg statistical relational learning when working at relational.ai, bidirectional type inference for imp.</li></ul><p>And of course my day-to-day work relies heavily on being able to construct proofs, analyze algorithms (with heavy caveats about using <a href="https://www.cse.wustl.edu/~angelee/archive/cse341/fall14/handouts/recitation03.pdf">realistic cost models</a> and not erasing constant factors), and being fluent in the various standard algorithmic techniques (hashing, sorting, recursion, amortization, memoization etc).</p><p>(See <a href="https://www.goodreads.com/book/show/192221.How_to_Solve_It">How to solve it</a> for proof heuristics, <a href="https://www.goodreads.com/book/show/739735.How_to_Prove_It">How to prove it</a> for core math literacy, <a href="https://www.goodreads.com/book/show/26619686-statistical-rethinking">Statistical rethinking</a> for modelling probabilistic problems.)</p><p>I've nothing against theory as a tool. If you do data science, learn statistics. If you do computer graphics, learn linear algebra. Etc.</p><p>And if you're interested in eg the theory of computation for its own sake, that's great. It's a fascinating subject. It just isn't an effective way to get better at programming, despite people regularly proclaiming otherwise.</p><hr><p>For all of the above, the real kicker is the <a href="https://www.stlouisfed.org/open-vault/2020/january/real-life-examples-opportunity-cost">opportunity cost</a>. The years that I spent messing around with haskell were not nearly as valuable to me as the week I spent learning to use <a href="https://rr-project.org/">rr</a>. Seeking out jobs where I could write erlang meant not seeking out jobs where I could learn how cpus work or how to manage a long-lived database. I don't write erlang any more, but I still use cpus sometimes.</p><p>Life is short and you don't get to learn more than a tiny fraction of the knowledge and skills available, so if you want to make really cool stuff then you need to spend most of your time on the highest-leverage options and spend only a little time on the lottery tickets.</p><p>I expect people to object that you never know what will turn out to be useful. But you can make smart bets.</p><p>If I could go back and do it again, I would spend the majority of my time trying to solve hard/interesting problems, using whatever were the mainstream languages and tools in that domain, and picking up any domain-specific knowledge that actually came up in the course of solving a problem. Focus on developing fluency and deep expertise in some area, rather than chasing the flavor of the day.</p><h2 id="intelligence-trumps-expertise">Intelligence trumps expertise</h2><p>People don't really say this explicitly, but it's conveyed by all the folk tales of the young college dropout prodigies revolutionizing everything they touch. They have some magic juice that makes them good at everything.</p><p>If I think that's how the world works, then it's easy to completely fail to learn. Whatever the mainstream is doing is ancient history, whatever they're working on I could do it in a weekend, and there's no point listening to anyone with more than 3 years experience because they're out of touch and lost in the past.</p><p>Similarly for programmers who go into other fields expecting to revolutionize everything with the application of software, without needing to spend any time learning about the actual problem or listening to the needs of the people who have been pushing the boulder up the hill for the last half century.</p><p>This error dovetails neatly with many of the previous errors above eg no point learning how existing query planners work if I'm smart enough to arrive at a better answer from a standing start, no point learning to use a debugger if I'm smart enough to find the bug in my head.</p><p>But a decade of mistakes later I find that I arrived at more or the less the point that I could have started at if I was willing to believe that the accumulated wisdom of tens of thousands of programmers over half a century was worth paying attention to.</p><p>And the older I get, the more I notice that the people who actually make progress are the ones who are keenly aware of the bounds of their own knowledge, are intensely curious about the gaps and are willing to learn from others and from the past. One exemplar of this is <a href="https://jvns.ca/">Julia Evans</a>, whose blog archives are a clear demonstration of how curiosity and lack of ego is a fast path to expertise.</p><h2 id="explore-vs-exploit">Explore vs exploit</h2><p>This is the core tradeoff embodied by many of the mistakes above. When faced with an array of choices, do you keep choosing the option that has a known payoff (exploit) or do you take a chance on something new and maybe discover a bigger payoff (explore).</p><p>I've consistently leaned way too hard towards explore, leaving me with a series of low payoff lottery tickets and a much less solid base to execute from.</p><p>If I had instead made a conscious decision to spend, say, 2/3rds of my time becoming truly expert in some core set of safe choices and only 1/3rd exploring new things, I believe I would have come out a much more capable programmer and be able to solve more interesting problems. Because I've watched some of my peers do exactly that.</p></article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><div class="spacer-1"></div><div>My work is currently funded by sharing thoughts and work in progress with people who <a href="https://github.com/sponsors/jamii">sponsor me</a> on github.</div></footer></div></body></html>